{"version":3,"file":"index.iife.js","sources":["../node_modules/atomico/chunk/constants.js","../node_modules/atomico/chunk/utils.js","../node_modules/atomico/core.js","../src/index.js"],"sourcesContent":["const HOOK_MOUNT = Symbol(\"mount\");\r\nconst HOOK_MOUNTED = Symbol(\"mounted\");\r\nconst HOOK_UPDATE = Symbol(\"update\");\r\nconst HOOK_UPDATED = Symbol(\"updated\");\r\nconst HOOK_UNMOUNT = Symbol(\"unmount\");\r\nconst HOOK_CURRENT = {};\r\n\r\nconst ELEMENT_PROPS = Symbol(\"props\");\r\nconst ELEMENT_IGNORE_ATTR = Symbol(\"ignore\");\r\nconst ELEMENT_TRUE_VALUES = [true, 1, \"\", \"1\", \"true\"];\r\n\r\nconst ARRAY_EMPTY = [];\r\n\r\nconst NODE_TYPE = \"localName\";\r\n\r\nconst KEY = Symbol(\"key\");\r\n\r\nconst META_STYLE_SHEET = Symbol(\"styleSheet\");\r\n\r\nconst META_MAP_CHILDREN = Symbol(\"mapChildren\");\r\n\r\nconst META_KEYES = Symbol(\"keyes\");\r\n\r\nconst NODE_HOST = \"host\";\r\n\r\nconst IGNORE_CHILDREN = {\r\n    innerHTML: 1,\r\n    textContent: 1,\r\n    contenteditable: 1\r\n};\r\n\r\nconst HYDRATE_PROPS = {\r\n    className: 1,\r\n    id: 1,\r\n    checked: 1,\r\n    value: 1,\r\n    selected: 1\r\n};\r\n\r\nconst CACHE_STYLE_SHEET = {};\r\n\r\nconst SUPPORT_STYLE_SHEET = \"adoptedStyleSheets\" in document;\r\n\r\nconst STYLE_SHEET_KEY = Symbol();\n\nexport { ARRAY_EMPTY as A, CACHE_STYLE_SHEET as C, ELEMENT_TRUE_VALUES as E, HOOK_CURRENT as H, IGNORE_CHILDREN as I, KEY as K, META_MAP_CHILDREN as M, NODE_HOST as N, SUPPORT_STYLE_SHEET as S, HOOK_MOUNT as a, HOOK_UPDATED as b, HOOK_MOUNTED as c, HOOK_UNMOUNT as d, HOOK_UPDATE as e, HYDRATE_PROPS as f, META_KEYES as g, META_STYLE_SHEET as h, STYLE_SHEET_KEY as i, NODE_TYPE as j, ELEMENT_PROPS as k, ELEMENT_IGNORE_ATTR as l };\n//# sourceMappingURL=constants.js.map\n","/**\r\n * Return if value is array\r\n * @param {*}\r\n * @return {boolean}\r\n */\r\nfunction isArray(value) {\r\n    return Array.isArray(value);\r\n}\r\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nfunction isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction isFunction(value) {\r\n    return typeof value == \"function\";\r\n}\r\n\r\n// export function fps(callback, count = 3) {\r\n//     count-- ? requestAnimationFrame(() => fps(callback, count)) : callback();\r\n// }\r\n\r\nfunction promise(callback) {\r\n    return new Promise(callback);\r\n}\n\nexport { isEqualArray as a, isArray as b, isFunction as i, promise as p };\n//# sourceMappingURL=utils.js.map\n","import { H as HOOK_CURRENT, a as HOOK_MOUNT, b as HOOK_UPDATED, c as HOOK_MOUNTED, d as HOOK_UNMOUNT, e as HOOK_UPDATE, A as ARRAY_EMPTY, I as IGNORE_CHILDREN, f as HYDRATE_PROPS, K as KEY, S as SUPPORT_STYLE_SHEET, C as CACHE_STYLE_SHEET, M as META_MAP_CHILDREN, g as META_KEYES, h as META_STYLE_SHEET, i as STYLE_SHEET_KEY, N as NODE_HOST, j as NODE_TYPE, E as ELEMENT_TRUE_VALUES, k as ELEMENT_PROPS, l as ELEMENT_IGNORE_ATTR } from './chunk/constants.js';\nimport { i as isFunction, a as isEqualArray, b as isArray, p as promise } from './chunk/utils.js';\n\nfunction update(hook, type) {\r\n    hook[0] && (hook[1] = hook[0](hook[1], type));\r\n}\r\n\r\nfunction updateAll(hooks, type) {\r\n    for (let i in hooks) update(hooks[i], type);\r\n}\r\n\r\nfunction useHook(reducer, initialState) {\r\n    if (HOOK_CURRENT.ref.hook) {\r\n        return HOOK_CURRENT.ref.hook.use(reducer, initialState)[1];\r\n    }\r\n}\r\n\r\nfunction useRender() {\r\n    return HOOK_CURRENT.ref.render;\r\n}\r\n\r\nfunction useHost() {\r\n    return useHook(0, { current: HOOK_CURRENT.ref.host });\r\n}\r\n\r\nfunction createHookCollection(render, host) {\r\n    let hooks = {};\r\n    let mounted;\r\n    let hook = {\r\n        use,\r\n        load,\r\n        updated,\r\n        unmount\r\n    };\r\n\r\n    let ref = { hook, host, render };\r\n\r\n    function load(callback, param) {\r\n        HOOK_CURRENT.index = 0;\r\n        HOOK_CURRENT.ref = ref;\r\n        let resolve = callback(param);\r\n        HOOK_CURRENT.ref = 0;\r\n        return resolve;\r\n    }\r\n    function use(reducer, state) {\r\n        let index = HOOK_CURRENT.index++;\r\n        let mount;\r\n        // record the hook and the initial state of this\r\n        if (!hooks[index]) {\r\n            hooks[index] = [null, state];\r\n            mount = 1;\r\n        }\r\n        // The hook always receives the last reduce.\r\n        hooks[index][0] = reducer;\r\n        update(hooks[index], mount ? HOOK_MOUNT : HOOK_UPDATE);\r\n        return hooks[index];\r\n    }\r\n    function updated() {\r\n        let type = mounted ? HOOK_UPDATED : HOOK_MOUNTED;\r\n        mounted = 1;\r\n        updateAll(hooks, type);\r\n    }\r\n    function unmount() {\r\n        updateAll(hooks, HOOK_UNMOUNT);\r\n    }\r\n    return hook;\r\n}\r\n\r\nfunction useState(initialState) {\r\n    let render = useRender();\r\n    return useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = isFunction(initialState) ? initialState() : initialState;\r\n            state[1] = nextState => {\r\n                nextState = isFunction(nextState)\r\n                    ? nextState(state[0])\r\n                    : nextState;\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useEffect(callback, args) {\r\n    // define whether the effect in the render cycle should be regenerated\r\n    let executeEffect;\r\n    useHook((state, type) => {\r\n        if (executeEffect == null) {\r\n            executeEffect =\r\n                args && state[0] ? !isEqualArray(args, state[0]) : true;\r\n            state[0] = args;\r\n        }\r\n\r\n        switch (type) {\r\n            case HOOK_UPDATE:\r\n            case HOOK_UNMOUNT:\r\n                // save the current args, for comparison\r\n                if ((executeEffect || type == HOOK_UNMOUNT) && state[1]) {\r\n                    // compare the previous snapshot with the generated state\r\n                    state[1]();\r\n                    // clean the effect collector\r\n                    state[1] = 0;\r\n                }\r\n                // delete the previous argument for a hook\r\n                // run if the hook is inserted in a new node\r\n                // Why? ... to perform again dom operations associated with the parent\r\n                if (type == HOOK_UNMOUNT) {\r\n                    state[0] = null;\r\n                }\r\n                break;\r\n            case HOOK_MOUNTED:\r\n            case HOOK_UPDATED:\r\n                // save the current args, for comparison, repeats due to additional type HOOK_MOUNTED\r\n                if (executeEffect || type == HOOK_MOUNTED) {\r\n                    // save the effect collector\r\n                    state[1] = callback();\r\n                }\r\n                // save the comparison argument\r\n                break;\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useRef(current) {\r\n    return useHook(0, { current });\r\n}\r\n\r\nfunction useMemo(callback, args = ARRAY_EMPTY) {\r\n    let state = useHook(0, []);\r\n\r\n    if (!state[0] || (state[0] && !isEqualArray(state[0], args))) {\r\n        state[1] = callback();\r\n    }\r\n    state[0] = args;\r\n    return state[1];\r\n}\r\n\r\nfunction useReducer(reducer, initialState) {\r\n    let render = useRender();\r\n    let hook = useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = initialState;\r\n            state[1] = action => {\r\n                let nextState = state[2](state[0], action);\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n    // allows the reduce to always access the scope of the component\r\n    hook[2] = reducer;\r\n\r\n    return hook;\r\n}\n\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {Object} props\r\n * @param {Object} nextProps\r\n * @param {boolean} isSvg\r\n * @param {Object} handlers\r\n **/\r\nfunction diffProps(node, props, nextProps, isSvg, handlers) {\r\n    props = props || {};\r\n\r\n    for (let key in props) {\r\n        if (!(key in nextProps)) {\r\n            setProperty(node, key, props[key], null, isSvg, handlers);\r\n        }\r\n    }\r\n    let ignoreChildren;\r\n    for (let key in nextProps) {\r\n        setProperty(node, key, props[key], nextProps[key], isSvg, handlers);\r\n        ignoreChildren = ignoreChildren || IGNORE_CHILDREN[key];\r\n    }\r\n    return ignoreChildren;\r\n}\r\n\r\nfunction setProperty(node, key, prevValue, nextValue, isSvg, handlers) {\r\n    key = key == \"class\" && !isSvg ? \"className\" : key;\r\n    // define empty value\r\n    prevValue = prevValue == null ? null : prevValue;\r\n    nextValue = nextValue == null ? null : nextValue;\r\n\r\n    if (key in node && HYDRATE_PROPS[key]) {\r\n        prevValue = node[key];\r\n    }\r\n\r\n    if (nextValue === prevValue) return;\r\n\r\n    if (\r\n        key[0] == \"o\" &&\r\n        key[1] == \"n\" &&\r\n        (isFunction(nextValue) || isFunction(prevValue))\r\n    ) {\r\n        setEvent(node, key, nextValue, handlers);\r\n        return;\r\n    }\r\n\r\n    switch (key) {\r\n        /**\r\n         * add support {@link https://developer.mozilla.org/es/docs/Web/API/CSSStyleSheet}\r\n         */\r\n        case \"styleSheet\":\r\n            if (SUPPORT_STYLE_SHEET)\r\n                node.shadowRoot.adoptedStyleSheets = []\r\n                    .concat(nextValue)\r\n                    .map(cssText => {\r\n                        if (cssText instanceof CSSStyleSheet) {\r\n                            return cssText;\r\n                        }\r\n                        if (!CACHE_STYLE_SHEET[cssText]) {\r\n                            CACHE_STYLE_SHEET[cssText] = new CSSStyleSheet();\r\n                            CACHE_STYLE_SHEET[cssText].replace(cssText);\r\n                        }\r\n\r\n                        return CACHE_STYLE_SHEET[cssText];\r\n                    });\r\n\r\n            break;\r\n        case \"ref\":\r\n            if (nextValue) nextValue.current = node;\r\n            break;\r\n        case \"style\":\r\n            setStyle(node, prevValue || \"\", nextValue || \"\");\r\n            break;\r\n        case \"key\":\r\n            node[KEY] = nextValue;\r\n            break;\r\n        default:\r\n            if (!isSvg && key != \"list\" && key in node) {\r\n                node[key] = nextValue == null ? \"\" : nextValue;\r\n            } else if (nextValue == null) {\r\n                node.removeAttribute(key);\r\n            } else {\r\n                node.setAttribute(\r\n                    key,\r\n                    typeof nextValue == \"object\"\r\n                        ? JSON.stringify(nextValue)\r\n                        : nextValue\r\n                );\r\n            }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {string} type\r\n * @param {function} [nextHandler]\r\n * @param {object} handlers\r\n */\r\nfunction setEvent(node, type, nextHandler, handlers) {\r\n    // get the name of the event to use\r\n    type = type.slice(type[2] == \"-\" ? 3 : 2);\r\n    // add handleEvent to handlers\r\n    if (!handlers.handleEvent) {\r\n        /**\r\n         * {@link https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener#The_value_of_this_within_the_handler}\r\n         **/\r\n        handlers.handleEvent = event => handlers[event.type].call(node, event);\r\n    }\r\n    if (nextHandler) {\r\n        // create the subscriber if it does not exist\r\n        if (!handlers[type]) {\r\n            node.addEventListener(type, handlers);\r\n        }\r\n        // update the associated event\r\n        handlers[type] = nextHandler;\r\n    } else {\r\n        // \tdelete the associated event\r\n        if (handlers[type]) {\r\n            node.removeEventListener(type, handlers);\r\n            delete handlers[type];\r\n        }\r\n    }\r\n}\r\n/**\r\n * define style as string inline,this generates less mutation\r\n * to the sun and cleans the previously defined properties.\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {(string|object)} prevValue\r\n * @param {(string|object)} nextValue\r\n */\r\nfunction setStyle(node, prevValue, nextValue) {\r\n    let style = node.style,\r\n        prevIsObject;\r\n    if (typeof prevValue == \"object\") {\r\n        prevIsObject = true;\r\n        for (let key in prevValue) {\r\n            if (!(key in nextValue)) setPropertyStyle(style, key, null);\r\n        }\r\n    }\r\n    if (typeof nextValue == \"object\") {\r\n        for (let key in nextValue) {\r\n            let value = nextValue[key];\r\n            if (prevIsObject && prevValue[key] === value) continue;\r\n            setPropertyStyle(style, key, value);\r\n        }\r\n    } else {\r\n        style.cssText = nextValue;\r\n    }\r\n}\r\n\r\nfunction setPropertyStyle(style, key, value) {\r\n    let method = \"setProperty\";\r\n    if (value == null) {\r\n        method = \"removeProperty\";\r\n        value = null;\r\n    }\r\n    if (~key.indexOf(\"-\")) {\r\n        style[method](key, value);\r\n    } else {\r\n        style[key] = value;\r\n    }\r\n}\n\nlet vNodeEmpty = createElement(null, { children: \"\" });\r\n\r\n/**\r\n * @param {VnodeType} nodeType\r\n * @param {VnodeProps} [props]\r\n * @param {Vnode|Vnode[]} [children]\r\n * @returns {Vnode}\r\n **/\r\nfunction createElement(nodeType, props, ...children) {\r\n    let vnode = { children, ...props, nodeType: nodeType || null };\r\n    return vnode;\r\n}\r\n/**\r\n * toVnode, processes the object for correct use within the diff process.\r\n **/\r\nfunction toVnode(value) {\r\n    if (isVnodeValue(value)) {\r\n        return value;\r\n    } else {\r\n        if (!value[META_MAP_CHILDREN]) {\r\n            let scan = mapChildren(value.children);\r\n            value.children = scan.children;\r\n            if (scan.keyes) {\r\n                value[META_KEYES] = scan.keyes;\r\n            }\r\n            value[META_MAP_CHILDREN] = true;\r\n        }\r\n        if (value.styleSheet && !SUPPORT_STYLE_SHEET) {\r\n            if (!value[META_STYLE_SHEET]) {\r\n                value.children.unshift(\r\n                    toVnode(\r\n                        createElement(\r\n                            \"style\",\r\n                            value[META_KEYES] ? { key: STYLE_SHEET_KEY } : {},\r\n                            value.styleSheet\r\n                        )\r\n                    )\r\n                );\r\n                if (value[META_KEYES]) {\r\n                    value[META_KEYES].unshift(STYLE_SHEET_KEY);\r\n                }\r\n            }\r\n            value[META_STYLE_SHEET] = true;\r\n        }\r\n    }\r\n    return value;\r\n}\r\n\r\nfunction mapChildren(children, scan = { children: [] }, deep = 0) {\r\n    if (isArray(children)) {\r\n        let length = children.length;\r\n        for (let i = 0; i < length; i++) {\r\n            mapChildren(children[i], scan, deep + 1);\r\n        }\r\n    } else {\r\n        if (children == null && !deep) return scan;\r\n\r\n        let vnode = toVnode(children);\r\n\r\n        if (vnode != null && typeof vnode == \"object\") {\r\n            if (isFunction(vnode.nodeType)) {\r\n                let { nodeType, ...props } = vnode;\r\n                return mapChildren(nodeType(props), scan, deep + 1);\r\n            }\r\n            if (\"key\" in vnode) {\r\n                scan.keyes = scan.keyes || [];\r\n                if (!~scan.keyes.indexOf(vnode.key)) {\r\n                    scan.keyes.push(vnode.key);\r\n                }\r\n            }\r\n        }\r\n\r\n        scan.children.push(vnode);\r\n    }\r\n    return scan;\r\n}\r\n\r\nfunction isVnodeEmpty(value) {\r\n    let type = typeof value;\r\n    return value == null || type == \"boolean\" || type == \"function\";\r\n}\r\n\r\nfunction fillVnodeValue(value) {\r\n    return isVnodeEmpty(value)\r\n        ? vNodeEmpty\r\n        : createElement(null, { children: \"\" + value });\r\n}\r\n\r\nfunction isVnodeValue(value) {\r\n    let type = typeof value;\r\n    return (\r\n        value == null ||\r\n        type == \"string\" ||\r\n        type == \"number\" ||\r\n        type == \"function\" ||\r\n        type == \"boolean\"\r\n    );\r\n}\r\n\r\n/**\r\n * @typedef {(Object<string,any>)} VnodeProps;\r\n *\r\n * @typedef {(Function|string)} VnodeType;\r\n *\r\n * @typedef {{type:VnodeType,props:VnodeProps}} Vnode\r\n **/\n\n/**\r\n *\r\n * @param {import(\"./render\").ConfigRender} config\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {import(\"./vnode\").Vnode} nextVnode\r\n * @param {boolean} isSvg\r\n * @param {Function} currentUpdateComponent\r\n * @return {import(\"./render\").HTMLNode}\r\n **/\r\nfunction diff(id, node, nextVnode, isSvg) {\r\n    let { vnode, handlers = {} } = (node && node[id]) || {};\r\n\r\n    if (vnode == nextVnode && vnode != null) return node;\r\n\r\n    nextVnode = isVnodeValue(nextVnode) ? fillVnodeValue(nextVnode) : nextVnode;\r\n\r\n    let { nodeType, shadowDom, children, ...props } = vnode || {};\r\n\r\n    let {\r\n        nodeType: nextNodeType,\r\n        shadowDom: nextShadowDom,\r\n        children: nextChildren,\r\n        ...nextProps\r\n    } = nextVnode;\r\n\r\n    isSvg = isSvg || nextNodeType == \"svg\";\r\n\r\n    if (nextNodeType != NODE_HOST && getNodeName(node) !== nextNodeType) {\r\n        let nextNode = createNode(nextNodeType, isSvg);\r\n        let parent = node && node.parentNode;\r\n\r\n        if (parent) {\r\n            parent.replaceChild(nextNode, node);\r\n        }\r\n\r\n        node = nextNode;\r\n        handlers = {};\r\n    }\r\n    if (nextNodeType == null) {\r\n        if (node.nodeValue != nextChildren) {\r\n            node.nodeValue = nextChildren;\r\n        }\r\n    } else {\r\n        if (shadowDom != nextShadowDom) {\r\n            let { shadowRoot } = node;\r\n            let mode =\r\n                nextShadowDom && !shadowRoot\r\n                    ? \"open\"\r\n                    : !nextShadowDom && shadowRoot\r\n                    ? \"closed\"\r\n                    : 0;\r\n            if (mode) node.attachShadow({ mode });\r\n        }\r\n\r\n        let ignoreChildren = diffProps(\r\n            node,\r\n            props,\r\n            nextProps,\r\n            isSvg,\r\n            handlers);\r\n        if (!ignoreChildren && children != nextChildren) {\r\n            diffChildren(\r\n                id,\r\n                nextShadowDom ? node.shadowRoot : node,\r\n                nextChildren,\r\n                nextProps[META_KEYES],\r\n                isSvg\r\n            );\r\n        }\r\n    }\r\n    node[id] = { vnode: nextVnode, handlers };\r\n    return node;\r\n}\r\n/**\r\n *\r\n * @param {import(\"./render\").ConfigRender} config\r\n * @param {import(\"./render\").HTMLNode} parent\r\n * @param {import(\"./vnode\").Vnode[]} [nextChildren]\r\n * @param {boolean} isSvg\r\n */\r\nfunction diffChildren(id, parent, children, keyes, isSvg) {\r\n    let childrenLenght = children.length;\r\n    let { childNodes } = parent;\r\n    let childNodesKeyes = {};\r\n    let childNodesLength = childNodes.length;\r\n    let index = keyes\r\n        ? 0\r\n        : childNodesLength > childrenLenght\r\n        ? childrenLenght\r\n        : childNodesLength;\r\n\r\n    for (; index < childNodesLength; index++) {\r\n        let childNode = childNodes[index];\r\n        let key = index;\r\n        if (keyes) {\r\n            key = childNode[KEY];\r\n            if (keyes.indexOf(key) > -1) {\r\n                childNodesKeyes[key] = childNode;\r\n                continue;\r\n            }\r\n        }\r\n        index--;\r\n        childNodesLength--;\r\n        parent.removeChild(childNode);\r\n    }\r\n    for (let i = 0; i < childrenLenght; i++) {\r\n        let child = children[i];\r\n        let indexChildNode = childNodes[i];\r\n        let key = keyes ? child.key : i;\r\n        let childNode = keyes ? childNodesKeyes[key] : indexChildNode;\r\n\r\n        if (keyes && childNode) {\r\n            if (childNode != indexChildNode) {\r\n                parent.insertBefore(childNode, indexChildNode);\r\n            }\r\n        }\r\n\r\n        let nextChildNode = diff(id, childNode, child, isSvg);\r\n\r\n        if (!childNode) {\r\n            if (childNodes[i]) {\r\n                parent.insertBefore(nextChildNode, childNodes[i]);\r\n            } else {\r\n                parent.appendChild(nextChildNode);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} type\r\n * @param {boolean} isSvg\r\n * @returns {import(\"./render\").HTMLNode}\r\n */\r\nfunction createNode(type, isSvg) {\r\n    let doc = document;\r\n    let nextNode;\r\n    if (type != null) {\r\n        nextNode = isSvg\r\n            ? doc.createElementNS(\"http://www.w3.org/2000/svg\", type)\r\n            : doc.createElement(type);\r\n    } else {\r\n        nextNode = doc.createTextNode(\"\");\r\n    }\r\n    return nextNode;\r\n}\r\n\r\n/**\r\n * returns the localName of the node\r\n * @param {import(\"./render\").HTMLNode} node\r\n */\r\nfunction getNodeName(node) {\r\n    if (!node) return;\r\n    if (!node[NODE_TYPE]) {\r\n        node[NODE_TYPE] = node.nodeName.toLowerCase();\r\n    }\r\n    let localName = node[NODE_TYPE];\r\n    return localName == \"#text\" ? null : localName;\r\n}\n\nfunction render(vnode, node, id = \"vnode\") {\r\n    if (\r\n        vnode != null &&\r\n        typeof vnode == \"object\" &&\r\n        vnode.nodeType != NODE_HOST\r\n    ) {\r\n        vnode = createElement(NODE_HOST, { children: vnode });\r\n    }\r\n    vnode = toVnode(vnode);\r\n    diff(id, node, vnode);\r\n    return node;\r\n}\n\nfunction setAttr(node, attr, value) {\r\n    if (value == null) {\r\n        node.removeAttribute(attr);\r\n    } else {\r\n        node.setAttribute(\r\n            attr,\r\n            typeof value == \"object\" ? JSON.stringify(value) : value\r\n        );\r\n    }\r\n}\r\n\r\nfunction formatType(value, type = String) {\r\n    try {\r\n        if (type == Boolean) {\r\n            value = ELEMENT_TRUE_VALUES.indexOf(value) > -1;\r\n        } else if (typeof value == \"string\") {\r\n            value =\r\n                type == Number\r\n                    ? Number(value)\r\n                    : type == Object || type == Array\r\n                    ? JSON.parse(value)\r\n                    : type == Date\r\n                    ? new Date(value)\r\n                    : value;\r\n        }\r\n        if ({}.toString.call(value) == `[object ${type.name}]`) {\r\n            return { value, error: type == Number && Number.isNaN(value) };\r\n        }\r\n    } catch (e) {}\r\n\r\n    return { value, error: true };\r\n}\r\n\r\nfunction propToAttr(prop) {\r\n    return prop.replace(/([A-Z])/g, \"-$1\").toLowerCase();\r\n}\r\n\r\nfunction attrToProp(attr) {\r\n    return attr.replace(/-(\\w)/g, (all, letter) => letter.toUpperCase());\r\n}\r\n\r\nfunction dispatchEvent(node, type, customEventInit) {\r\n    node.dispatchEvent(\r\n        new CustomEvent(\r\n            type,\r\n            typeof customEventInit == \"object\" ? customEventInit : null\r\n        )\r\n    );\r\n}\n\nlet defer = Promise.resolve();\r\nlet queue = [];\r\nlet running;\r\n\r\nlet maxFps = 1000 / 60;\r\n\r\nconst IMPORTANT = Symbol(\"important\");\r\n\r\nfunction clearQueue() {\r\n    let time = performance.now();\r\n\r\n    let length = queue.length;\r\n    let current = queue;\r\n\r\n    queue = [];\r\n\r\n    while (length--) {\r\n        let callback = current[length];\r\n        if (callback[IMPORTANT] || performance.now() - time < maxFps) {\r\n            callback();\r\n        } else {\r\n            queue = queue.concat(current.slice(0, length + 1));\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (queue.length) {\r\n        requestAnimationFrame(clearQueue);\r\n        return;\r\n    }\r\n    running = false;\r\n}\r\n/**\r\n * add a task to the queue\r\n * @param {Function} callback\r\n * @returns {Promise} Generate a promise that show  if the queue is complete\r\n */\r\nfunction addQueue(callback) {\r\n    if (!running) {\r\n        running = true;\r\n        defer.then(clearQueue);\r\n    }\r\n    if (!queue.includes(callback)) queue.push(callback);\r\n}\n\nclass Element extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        /**\r\n         * identifier to store the virtual-dom state,\r\n         * this is unique between instances of the\r\n         * component to securely consider the host status\r\n         */\r\n        let id = Symbol(\"vnode\");\r\n\r\n        let isPrevent;\r\n        let isUnmount;\r\n\r\n        this[ELEMENT_PROPS] = {};\r\n\r\n        let isMounted;\r\n\r\n        let resolveUpdate;\r\n\r\n        let rerender = () => {\r\n            // disables blocking, allowing the cycle to be regenerate\r\n            isPrevent = false;\r\n            // After the first render it disables the important condition\r\n            if (rerender[IMPORTANT]) rerender[IMPORTANT] = false;\r\n            try {\r\n                render(\r\n                    hooks.load(this.render, { ...this[ELEMENT_PROPS] }),\r\n                    this,\r\n                    id\r\n                );\r\n\r\n                resolveUpdate();\r\n            } catch (e) {\r\n                this.error(e);\r\n            }\r\n        };\r\n        // mark the first render as important, this speeds up the rendering\r\n        rerender[IMPORTANT] = true;\r\n\r\n        this.update = () => {\r\n            if (isUnmount) return;\r\n            let rendered = this.rendered;\r\n            if (!isPrevent) {\r\n                isPrevent = true;\r\n                // create a promise to observe the status of the update\r\n                rendered = promise(resolve => (resolveUpdate = resolve)).then(\r\n                    // the UPDATED state is only propagated through\r\n                    // the resolution of the promise\r\n                    // Why? ... to improve communication between web-component parent and children\r\n                    hooks.updated\r\n                );\r\n\r\n                // if the component is already mounted, avoid using this.mounted,\r\n                // to speed up the microtask\r\n                isMounted\r\n                    ? addQueue(rerender)\r\n                    : this.mounted.then(() => {\r\n                          isMounted = true;\r\n                          addQueue(rerender);\r\n                      });\r\n            }\r\n\r\n            return (this.rendered = rendered);\r\n        };\r\n\r\n        // any update from hook is added to a separate queue\r\n        let hooks = createHookCollection(() => addQueue(this.update), this);\r\n\r\n        // creates a collection of microtask\r\n        // associated with the mounted of the component\r\n\r\n        this.mounted = promise(\r\n            resolve =>\r\n                (this.mount = () => {\r\n                    isMounted = false;\r\n                    // allows the reuse of the component when it is isUnmounted and mounted\r\n                    if (isUnmount == true) {\r\n                        isUnmount = false;\r\n                        this.mounted = this.update();\r\n                    }\r\n                    resolve();\r\n                })\r\n        );\r\n        /**\r\n         * creates a collection of microtask\r\n         * associated with the unmounted of the component\r\n         */\r\n        this.unmounted = promise(\r\n            resolve =>\r\n                (this.unmount = () => {\r\n                    isUnmount = true;\r\n                    hooks.unmount();\r\n                    resolve();\r\n                })\r\n        );\r\n\r\n        this.initialize();\r\n\r\n        this.update();\r\n    }\r\n    connectedCallback() {\r\n        this.mount();\r\n    }\r\n    disconnectedCallback() {\r\n        this.unmount();\r\n    }\r\n    attributeChangedCallback(attr, oldValue, value) {\r\n        if (attr === this[ELEMENT_IGNORE_ATTR] || oldValue === value) return;\r\n        this[attrToProp(attr)] = value;\r\n    }\r\n}\r\n\r\n/**\r\n * register the component, be it a class or function\r\n * @param {string} nodeType\r\n * @param {Function} component\r\n * @return {Function} returns a jsx component\r\n */\r\nfunction customElement(nodeType, component) {\r\n    if (isFunction(nodeType)) {\r\n        component = nodeType;\r\n\r\n        let CustomElement = class extends Element {};\r\n        let prototype = CustomElement.prototype;\r\n\r\n        let props = component.props;\r\n\r\n        prototype.error = component.error || console.error;\r\n        prototype.render = component;\r\n\r\n        prototype.initialize = function() {\r\n            let length = initialize.length;\r\n            while (length--) initialize[length](this);\r\n        };\r\n\r\n        let initialize = [];\r\n\r\n        let attrs = [];\r\n\r\n        for (let prop in props)\r\n            setProperty$1(prototype, initialize, attrs, prop, props[prop]);\r\n\r\n        CustomElement.observedAttributes = attrs;\r\n\r\n        return CustomElement;\r\n    } else {\r\n        customElements.define(\r\n            nodeType,\r\n            component instanceof Element ? component : customElement(component)\r\n        );\r\n\r\n        return props => createElement(nodeType, props);\r\n    }\r\n}\r\n\r\nfunction setProperty$1(prototype, initialize, attrs, prop, schema) {\r\n    let attr = propToAttr(prop);\r\n\r\n    schema = schema.name ? { type: schema } : schema;\r\n\r\n    if (prop in prototype) return;\r\n\r\n    function set(nextValue) {\r\n        let prevValue = this[ELEMENT_PROPS][prop];\r\n\r\n        if (isFunction(nextValue)) {\r\n            nextValue = nextValue(prevValue);\r\n        }\r\n        let { value, error } = formatType(nextValue, schema.type);\r\n\r\n        if (error && value != null) {\r\n            throw `the observable [${prop}] must be of the type [${schema.type.name}]`;\r\n        }\r\n\r\n        if (prevValue == value) return;\r\n\r\n        this[ELEMENT_PROPS][prop] = value;\r\n\r\n        let rendered = this.update();\r\n\r\n        if (schema.event) {\r\n            rendered.then(() =>\r\n                dispatchEvent(this, schema.event.type || prop, schema.event)\r\n            );\r\n        }\r\n\r\n        if (schema.reflect) {\r\n            // the default properties are only reflected once the web-component is mounted\r\n            this.mounted.then(() => {\r\n                this[ELEMENT_IGNORE_ATTR] = attr; //update is prevented\r\n                setAttr(\r\n                    this,\r\n                    attr,\r\n                    schema.type == Boolean && !value ? null : value //\r\n                );\r\n                this[ELEMENT_IGNORE_ATTR] = false; // an upcoming update is allowed\r\n            });\r\n        }\r\n    }\r\n\r\n    function get() {\r\n        return this[ELEMENT_PROPS][prop];\r\n    }\r\n\r\n    Object.defineProperty(prototype, prop, { set, get });\r\n\r\n    if (\"value\" in schema) {\r\n        initialize.push(self => (self[prop] = schema.value));\r\n    }\r\n    attrs.push(attr);\r\n}\n\nfunction useProp(name) {\r\n    let ref = useHost();\r\n    if (name in ref.current) {\r\n        if (!ref[name]) {\r\n            ref[name] = [null, nextValue => (ref.current[name] = nextValue)];\r\n        }\r\n        ref[name][0] = ref.current[name];\r\n        return ref[name];\r\n    }\r\n}\r\n\r\nfunction useEvent(type, customEventInit) {\r\n    let ref = useHost();\r\n    if (!ref[type]) {\r\n        ref[type] = detail =>\r\n            dispatchEvent(\r\n                ref.current,\r\n                type,\r\n                detail ? { ...customEventInit, detail } : customEventInit\r\n            );\r\n    }\r\n    return ref[type];\r\n}\r\n\r\nfunction usePublic(name, value) {\r\n    let { current } = useHost();\r\n    if (current[name] != value) {\r\n        current[name] = value;\r\n    }\r\n    return current[name];\r\n}\n\nexport { Element, createHookCollection, customElement, createElement as h, render, toVnode, useEffect, useEvent, useHook, useHost, useMemo, useProp, usePublic, useReducer, useRef, useRender, useState };\n//# sourceMappingURL=core.js.map\n","/*@jsx h*/\r\nimport { h, customElement } from \"atomico\";\r\n\r\nconst CustomElement = () => <host shadowDom>inside web-component</host>;\r\n\r\ncustomElement(\"custom-element\", CustomElement);\r\n"],"names":["CustomElement","h","customElement"],"mappings":"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"}